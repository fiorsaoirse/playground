// https://github.com/jscomplete/book-node-beyond-basics/blob/master/200-requiring-modules.adoc

/*
    Node использует 2 core-модуля для управления зависимостями:
    * require модуль, который доступен в глобальном окружении (нет необходимости писать require('require'))
    * module модуль, который также доступен в глобальном окружении

    Можно думать о require модуле как о КОМАНДЕ
    и module модуле как об ОРГАНАЙЗЕРЕ зависимостей

    Использование зависимости в модуле:

    const config = require('/path/to/file');

    

    Стадии, которые проходит Node при загрузке зависимостей:
    1. Resolving - найти абсолютный путь до файла
    2. Loading - чтение файла, определение типа контента
    3. Wrapping - файл "оборачивается" в IIFE, получает собственный скоуп. В нем же идет
    определение и передача в этот скоуп переменных (exports, require, module, __filename, __dirname)
    4. Evaluating - выполнение файла (вызов IIFE)
    5. Caching - кэширование, теперь при любом требовании файла будет загружаться его кэшированная версия

    Модуль имеет следующую структуру в ноде:

    Module {
        id: '<repl>',
        exports: {},
        parent: undefined,
        filename: null,
        loaded: false,
        children: [],
        paths: [ ... ]
    }

    Каждый модуль получает айди, обычно это полный путь до файла, но в REPL это просто 'repl'.
    Модуль имеет связь один-к-одному с файлами в ФС. Мы 'require' модуль = мы загружаем его содержимое в память.
    Но прежде, чем загрузить модуль, надо его найти.
    Нода делает это на этапе Resolving в семь шагов.

    https://nodejs.org/api/modules.html

    Ищем модуль X.

    1. Если модуль X - это core модуль, загружаем его и останавливаемся.
    2. Если путь до X начинается с '/' - устанавливаем Y как корень ФС.
    3. Если путь до X начинается с './' или '/' или '../'
        3.1. Пробуем загрузить как файл LOAD_AS_FILE(Y + X) 
        3.2. Пробуем загрузить как директорию LOAD_AS_DIR(Y + X)
        3.3. Кидаем ошибку "не найдено"
    4. Если путь до X начинается с "#" - грузим модуль как пакет LOAD_AS_PACKAGE
    5. Пробуем загрузить PACKAGE_SELF (package.json)
    6. Пробуем загрузить в NODE_MODULES
    7. Кидаем ошибку "не найдено"

    Модуль можно только зарезолвить и не переходить к следующему этапу (например, чисто
    для проверки, что зависимость установлена). Для этого используется конструкция require.resovle('path')

    В любом модуле exports - специальный объект, куда записываются ссылки\значения, которые мы хотим экспортировать.
    Внутри самого модуля exports - ВСЕГО ЛИШЬ ССЫЛКА на module.exports,
    а вот module.exports - ОРГАНАЙЗЕР зависимостей (блок exports в самом модуле).
    Именно module.exports - тот объект, который возвращается при вызове функции require('path').
    Переопределять саму переменную exports бессмыссленно и беспощадно - ссылка будет утеряна, ничего не экспортируется.

    Все модули загружаются синхронно. Поэтому нет возможности заменить экспорты уже ПОСЛЕ того, как модуль
    был загружен.

    Что произойдет, когда модулю1 необходим модуль2, а модулю2 необходим модуль1?
    
    lib/module1.js
    {
        exports.a = 1;

        require("./module2");

        exports.b = 2;
        exports.c = 3;
    }

    lib/module2.js
    {
        const Module1 = require("./module1");
        console.log("Module1 is partially loaded here", Module1);
    }
     
    При выполнении модуля1:

    $ node lib/module1.js
    Module1 is partially loaded here { a: 1 }

    Модуль1 был загружен частично, поэтому в модуле2 нет всех экспортов из модуля1.

*/